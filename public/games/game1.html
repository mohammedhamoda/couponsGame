<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catch the Items â€” Demo</title>
  <link rel="stylesheet" href="../style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Handjet:wght@100..900&display=swap" rel="stylesheet">
</head>
<body>
  <div id="gameWrap">
    <canvas id="canvas" width="400" height="600"></canvas>
    <div id="overlay"></div>
  </div>
  <div id="info">
    <center>
      <div id="points">Ø³ÙƒÙˆØ±Ùƒ : 0</div>
    </center>
  </div>

<script>
// ====== CONFIG ======
const MAX_POINTS = 100; // win condition
const IMAGES_PATH = '/images/';
const itemFiles = ['item1.png','item2.png','item3.png','item4.png','item5.png'];
const binFile = 'bin.png';
const SERVER_BASE = ''; // same origin (served from server)
const GAME_ID = "fallingItems"; // <--- game identifier

// ====== SETUP ======
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const pointsEl = document.getElementById('points');
let W = canvas.width, H = canvas.height;

let deviceId = localStorage.getItem('deviceId');
if(!deviceId){ deviceId = uuidv4(); localStorage.setItem('deviceId', deviceId); }

const binImg = new Image(); binImg.src = IMAGES_PATH + binFile;
const itemImgs = itemFiles.map(f => { const i = new Image(); i.src = IMAGES_PATH + f; return i; });

let bin = { x: (W-80)/2, y: H - 70, width: 80, height: 60, speed: 6 };
let items = [];
let points = 0;
let itemSpeed = 4.0;
let spawnInterval = 1000;
let gameOver = false;
let spawnTimer = null;

// ====== NETWORK ======
async function checkCanPlay(){
  try{
    const res = await fetch(`${SERVER_BASE}/can-play?deviceId=${encodeURIComponent(deviceId)}`);
    if(!res.ok) return {canPlay:true};
    return await res.json();
  }catch(e){ return {canPlay:true}; }
}

async function claimCoupon(score){
  try {
    const res = await fetch(`${SERVER_BASE}/claim-coupon`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ deviceId, score, gameId: GAME_ID }) // send gameId too
    });
    const j = await res.json();
    if (j.ok) {
      showOverlay(`ðŸŽ‰ You win! Coupon: ${j.coupon}`);
    } else {
      showOverlay(j.error || 'No coupon: ' + (j.message || 'unknown'));
    }
  } catch (e) {
    showOverlay('Cannot contact server. Try later.');
  }
}

async function recordPlay(){
  try{ 
    await fetch(`${SERVER_BASE}/record-play`, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ deviceId, gameId: GAME_ID })
    });
  }catch(e){}
}

// ====== GAME FUNCTIONS ======
function spawnItem(){
  const w = 36, h = 36;
  const imgIndex = Math.floor(Math.random() * itemImgs.length);
  items.push({ x: Math.random() * (W - w), y: -h - 10, width: w, height: h, imgIndex });
}

function spawnItems(){
  let count = Math.min(3, 1 + Math.floor(points / 5));
  for (let i = 0; i < count; i++) {
    let gap = Math.max(200, 500 - points * 10);
    setTimeout(() => spawnItem(), i * gap);
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.drawImage(binImg, bin.x, bin.y, bin.width, bin.height);
  for(let it of items){
    const img = itemImgs[it.imgIndex];
    if(img.complete) ctx.drawImage(img, it.x, it.y, it.width, it.height);
    else { ctx.fillStyle='#ddd'; ctx.fillRect(it.x,it.y,it.width,it.height); }
  }
}

function update(){
  for(let i=items.length-1;i>=0;i--){
    items[i].y += itemSpeed;
    const it = items[i];
    if(it.y + it.height >= bin.y && it.x < bin.x + bin.width && it.x + it.width > bin.x){
      items.splice(i,1);
      points += 1;
      itemSpeed += .4;
      pointsEl.textContent = 'Ø³ÙƒÙˆØ±Ùƒ : ' + points;

      if (points >= MAX_POINTS) {
        gameOver = true;
        stopSpawning();
        claimCoupon(points);
      }
    } else if (it.y > H) {
      gameOver = true;
      stopSpawning();
      claimCoupon(points); // FIXED: was "score"
      showOverlay('Game over! Your score: ' + points);
    }
  }
}

function loop(){
  if(gameOver) return;
  update();
  draw();
  requestAnimationFrame(loop);
}

function startSpawning(){ spawnTimer = setInterval(spawnItems, spawnInterval); }
function stopSpawning(){ if(spawnTimer) clearInterval(spawnTimer); spawnTimer = null; }

function resetGame(){
  items = []; points = 0; itemSpeed = 4; gameOver = false;
  pointsEl.textContent = 'Ø³ÙƒÙˆØ±Ùƒ : 0'; overlay.style.visibility='hidden';
  bin.x = (W - bin.width)/2;
  startSpawning(); loop();
}

function showOverlay(html){
  overlay.innerHTML = `<div style="text-align:center">${html}</div>
    <div style="margin-top:12px">
      <button class="btn btn-primary" onclick="resetGame()">Play again</button>
    </div>`;
  overlay.style.visibility='visible';
}

// ====== INPUT ======
let dragging = false, dragStartX = 0, binStartX = 0;
canvas.addEventListener('pointerdown', e => {
  dragging = true; dragStartX = e.clientX; binStartX = bin.x;
  canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', e => {
  if (!dragging) return;
  const dx = (e.clientX - dragStartX) * (canvas.width / canvas.getBoundingClientRect().width);
  bin.x = Math.max(0, Math.min(W - bin.width, binStartX + dx));
});
canvas.addEventListener('pointerup', e => { dragging = false; });

canvas.addEventListener('touchmove', e => {
  const touch = e.touches[0]; const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  bin.x = Math.max(0, Math.min(W - bin.width, x * (canvas.width / rect.width) - bin.width/2));
  e.preventDefault();
});

window.addEventListener('keydown', e => {
  if (gameOver) return;
  if (e.key === 'ArrowLeft') bin.x = Math.max(0, bin.x - bin.speed);
  if (e.key === 'ArrowRight') bin.x = Math.min(W - bin.width, bin.x + bin.speed);
});

// ====== UTIL ======
function uuidv4(){ return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
  const r = Math.random() * 16 | 0, v = c=='x' ? r : (r & 0x3 | 0x8);
  return v.toString(16);
}); }

// ====== BOOT ======
(async function boot(){
  const can = await checkCanPlay();
  if(!can.canPlay){ showOverlay(can.reason || 'Already played today'); return; }
  setTimeout(()=>{ draw(); startSpawning(); loop(); }, 300);
})();
</script>
</body>
</html>
